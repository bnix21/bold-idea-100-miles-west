<html>
<link rel="stylesheet" type="text/css" href="css/style.css">

<head></head>

<body>
    <div id="blocker">
        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br /> (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
        </div>
    </div>
    
    <progress id="health" value="100" max="100"></progress>

    <!-- Include other libraries here (keep three.js at the top): -->
    <script src="js/Three.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <script src="js/Enemy.js"></script>
    <script src="js/physi.js"></script>
    <!--<script src="js/OrbitControls.js"></script>-->
    <script src="js/ColladaLoader.js"></script>
     <script src="js/Scoreboard.js"></script>

    <script>
        Physijs.scripts.worker = 'js/physijs_worker.js';
        Physijs.scripts.ammo = 'ammo.js';
    
        /* global THREE, Scoreboard, Physijs*/
        var camera, scene, renderer, controls, player, mixer, zombie, bullets, isShooting, playerHeight;
        
        /**
         * Player WASD Controls
         */
        // Keep track of W, A, S, D keypresses
        var keyW = false;
        var keyA = false;
        var keyS = false;
        var keyD = false;
        
        var playerAttributes = { height:6, speed:0.2, turnSpeed:Math.PI*0.02, canShoot:0 };
        
        var objects = [];
        var bullets = [];
        var mouseCoords = new THREE.Vector2();
        var projector = new THREE.Projector();
        
        var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
        var pos = new THREE.Vector3();
        
        var blocker = document.getElementById('blocker');
        var instructions = document.getElementById('instructions');
        // http://www.html5rocks.com/en/tutorials/pointerlock/intro/
        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
        
        if (havePointerLock) {
            var element = document.body;
            var pointerlockchange = function(event) {
                if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                    controlsEnabled = true;
                    controls.enabled = true;
                    blocker.style.display = 'none';
                }
                else {
                    controls.enabled = false;
                    blocker.style.display = 'block';
                    instructions.style.display = '';
                }
            };
            var pointerlockerror = function(event) {
                instructions.style.display = '';
            };
            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerlockchange, false);
            document.addEventListener('mozpointerlockchange', pointerlockchange, false);
            document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
            document.addEventListener('pointerlockerror', pointerlockerror, false);
            document.addEventListener('mozpointerlockerror', pointerlockerror, false);
            document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
            instructions.addEventListener('click', function(event) {
                instructions.style.display = 'none';
                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                element.requestPointerLock();
            }, false);
        }
        else {
            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
        }
        
        init();
        animate();

        var controlsEnabled = false;
        var moveForward = false;
        var moveBackward = false;
        var moveLeft = false;
        var moveRight = false;
        var canJump = false;
        isShooting = false;
        var prevTime = performance.now();
        var velocity = new THREE.Vector3();
        var direction = new THREE.Vector3();
        var shoot = false;

        function init() {
            // Setup the scene
            scene = new Physijs.Scene();
            scene.setGravity(new THREE.Vector3(0, -9.87, 0));
            scene.background = new THREE.Color(0xffffff);
            scene.fog = new THREE.Fog(0xffffff, 0, 750);
            
            // Setup the floor of our scene
            var floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);
            
            for (var i = 0, l = floorGeometry.vertices.length; i < l; i++) {
                var vertex = floorGeometry.vertices[i];
                vertex.x += Math.random() * 20 - 10;
                vertex.y += Math.random() * 2;
                vertex.z += Math.random() * 20 - 10;
            }
            for (var i = 0, l = floorGeometry.faces.length; i < l; i++) {
                var face = floorGeometry.faces[i];
                face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            }
            
            var floorMaterial = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors });
            
            var floor = new Physijs.BoxMesh(floorGeometry, //new THREE.BoxGeometry(2000, 1, 2000),//2000, 1, 2000), 
                                            floorMaterial,//new THREE.MeshBasicMaterial({color: 0xCCCCCC}),
                                            0);
                                            
            scene.add(floor);
				
			var loader = new THREE.ObjectLoader();
			loader.load('models/gears-of-war-3-lambent-female.json',
			            function(obj)
			            {
			                var zombieHeight = 6;
			                var zombieFriction = 0.5;
			                var zombieRestitution = 0.1;
			                var zombieMaterial = Physijs.createMaterial(new THREE.MeshNormalMaterial({ wireframe: true, opacity: 0.5 }),
			                                                            zombieFriction,
			                                                            zombieRestitution);
			                zombie = new Physijs.CapsuleMesh(new THREE.CylinderGeometry(1, 1, zombieHeight),
                			                                 zombieMaterial,
                			                                 1);
                			                                 
                			zombie.Health = 100;
                			                                 
                			zombie.addEventListener('collision', 
                			                        function(other_object, relative_velocity, relative_rotation, contact_normal) 
                			                        {
                			                            console.log('collision detected!')
                			                            
                			                            if (other_object.type == 'bullet')
                			                            {
                			                                other_object.alive = false;
                			                                
                                                            // the zombie has been hit!
                                                            this.Health -= 20;
                                                        
                                                            if (this.Health <= 0)
                                                            {
                                                                // Bye zombie!
                                                                scene.remove(this);
                                                            }
                			                            }
                			                            
                			                            if (other_object.type == 'player')
                			                            {
                			                                //TODO: Decide whether or not we die as soon as we get touched
                			                                //by a zombie or if the player is allowed a certain amount of health
                			                                //that decreases when we collide and/or touch.
                			                                
                			                                other_object.Health -= 25;
                			                                
                			                                
                			                                
                			                                var healthbar = document.getElementById("health")
                                                               healthbar.value = other_object.Health;
                			                                
                			                                //if (other_object.Health <= 0)
                			                                //{
                			                                    ////TODO: Uh-oh, GAME OVER!
                			                                    //console.log('GAME OVER!!!');
                			                                //}
                			                            }
                			                        });
                			                                 
                			zombie.position.x = 23;
			                zombie.position.z = 23;
			                zombie.position.y = 3 + zombieHeight / 2;// 20; to make the zombie's float down...
			                
			                //obj.scale(2, 2, 2);
			                obj.position.set(0, -zombieHeight / 2, 0);
			                zombie.add(obj);
			                scene.add(zombie);
			                zombie.setAngularFactor({ x: 0, y: 0, z: 0 });
			            });
			            
			// Setup our weapon
			var loader = new THREE.ObjectLoader();
			loader.load('models/weapons/sword/minecarft-sword.json',
			            function(obj)
			            {
			                
			            });
			            
            // Setup our player.  Use CapsuleMesh so it can have more
            // realistic human-like movement
            playerHeight = 6;
            var playerFriction = 0.8;
			var playerRestitution = 1;
			var playerMaterial = Physijs.createMaterial(new THREE.MeshNormalMaterial(),
                                                        playerFriction,
                                                        playerRestitution);
            player = new Physijs.CapsuleMesh(new THREE.CylinderGeometry(1, 1, playerHeight),
                                             playerMaterial,
                                             1);
                                             
            player.visible = true;//false; // FPS
            player.position.x = 30;
            player.position.z = 30;
            player.position.y = playerHeight / 2 + 2;
            //player.rotation.y = -Math.PI / 2;
            player.type = 'player';
            player.Health = 100;
            player.canShoot = 0;
            scene.add(player);
            player.setAngularFactor({ x: 0, y: 0, z: 0 });
            
            // Setup the camera
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1000);
            
            //player.rotation.y = Math.PI / 2;

            // Setup lighting
            var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);
            
            // Setup the pointer lock controls
            controls = new THREE.PointerLockControls(camera);
            scene.add(controls.getObject());
            
            // Use the controls object as the player's POV
            var pov = controls.getObject();
            player.add(pov);
            pov.position.set(0, 0, 0);
            //pov.position.set(0, 0, 5); // back the camera away from our player.  can use for debug.
            
            var onKeyDown = function(event) {

                switch (event.keyCode) {
                    case 38: // up
                    case 87: // w
                        moveForward = true;
                        break;
                    case 37: // left
                    case 65: // a
                        moveLeft = true;
                        break;
                    case 40: // down
                    case 83: // s
                        moveBackward = true;
                        break;
                    case 39: // right
                    case 68: // d
                        moveRight = true;
                        break;
                    case 32: // space
                        //if (canJump === true) //playerVelocity.y += 3;
                        //canJump = false;
                        //isShooting = true;
                        
                        var bulletSpeed = 300;//0;
                        var bulletSize = 5;
                        var bulletMass = .15;
                        
                        var aimVector = new THREE.Vector3();
                        camera.getWorldDirection(aimVector);
                        
                        fireBullet(new THREE.Vector3(bulletSpeed*aimVector.x, 
                                                     bulletSpeed*aimVector.y, 
                                                     bulletSpeed*aimVector.z,
                                                     bulletSize),
                                   bulletMass);
                        
                        break;
                }
            };
            
            var onKeyUp = function(event) {
                switch (event.keyCode) {
                    case 38: // up
                    case 87: // w
                        moveForward = false;
                        break;
                    case 37: // left
                    case 65: // a
                        moveLeft = false;
                        break;
                    case 40: // down
                    case 83: // s
                        moveBackward = false;
                        break;
                    case 39: // right
                    case 68: // d
                        moveRight = false;
                        break;
                    case 32: // space
                        //isShooting = false;
                        //break;
                }
            };
            
            	var not_allowed = [];
	var scoreboard = new Scoreboard();
	scoreboard.countdown(2000);
	scoreboard.score();
	scoreboard.help(	);
	
	var game_over = false;
	scoreboard.onTimeExpired(function() {
		scoreboard.message("Game Over!");
		game_over = true;
	});
            
     
            
            
            
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            //****begin world creation****

            //B represents a brick building
            //G represents a glass building
            var map = "B       G\n" +
                "     G  B\n" +
                "B       G\n" +
                "   B    B\n" +
                "B       G\n" +
                "        B\n" +
                "B       G\n" +
                "        B\n" +
                "B     G G";

            //convert our above string into arrays
            map = map.split("\n");
            var HORIZONTAL_UNIT = 100,
                VERTICAL_UNIT = 1000,
                ZSIZE = map.length * HORIZONTAL_UNIT,
                XSIZE = map[0].length * HORIZONTAL_UNIT;

            for (var i = 0, rows = map.length; i < rows; i++) {
                for (var j = 0, cols = map[i].length; j < cols; j++) {
                    addObject(map[i].charAt(j), i, j);
                }
            }

            function addObject(type, row, col) {
                var z = (row + 1) * HORIZONTAL_UNIT - ZSIZE * 0.5,
                    x = (col + 1) * HORIZONTAL_UNIT - XSIZE * 0.5;

                var mesh, geo, material;

                if (type == '') {

                }
                else if (type == 'B') {
                   var brickTexture = THREE.ImageUtils.loadTexture('textures/brick.jpg');
                    brickTexture.wrapS = brickTexture.wrapT = THREE.RepeatWrapping;
                    brickTexture.repeat.set(10, 50);
                   
                   
                    geo = new Physijs.BoxMesh(
                        new THREE.CubeGeometry(HORIZONTAL_UNIT, VERTICAL_UNIT, HORIZONTAL_UNIT),
                        new THREE.MeshBasicMaterial({map: brickTexture}),
                        100000000
                        );
                   
                    geo.position.set(x, VERTICAL_UNIT * 0.5, z);
                    scene.add(geo);
                }
                else if (type == 'G') {
                    var windowTexture = THREE.ImageUtils.loadTexture('textures/glasswindows.jpg');
                    windowTexture.wrapS = windowTexture.wrapT = THREE.RepeatWrapping;
                    windowTexture.repeat.set(10, 50);
                    
                    geo = new Physijs.BoxMesh(
                        new THREE.CubeGeometry(HORIZONTAL_UNIT, VERTICAL_UNIT, HORIZONTAL_UNIT),
                        new THREE.MeshBasicMaterial({map: windowTexture}),
                        100000000
                        );
                        
                    geo.position.set(x, VERTICAL_UNIT * 0.5, z);
                    scene.add(geo);
                }
            }
        
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            //
            window.addEventListener('resize', onWindowResize, false);
        }
  
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            scene.simulate();
            handleBullets();
            controlPlayer();
            controlZombie();
                
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        
        function handleBullets()
        {
            // go through bullets array and update position
	        // remove bullets when appropriate
	        for(var index=0; index<bullets.length; index+=1)
	        {
	            if(bullets[index] === undefined ) continue;
	            
	            if(bullets[index].alive == false )
	            {
	                bullets.splice(index,1);
	                continue;
		        }
		        
		        //4/6/2018
		        //bullets[index].position.add(bullets[index].velocity);
	        }
        }
    
        function controlPlayer() 
        {
            if (controlsEnabled == true) 
            {
                if (moveForward || moveBackward || moveLeft || moveRight)
                {
                    // Change this to the speed you want your player to move
                    var speed = 25;
                    
                    // Our player is a pill shape, so this keeps our player from accidentally tipping over
                    player.setAngularFactor({ x: 0, y: 0, z: 0 });
                    
                    // We want to rotate our vector around the Y axis
                    var rotateAxis = new THREE.Vector3(0, 1, 0);
                    
                    // Get a vector based on our direction
                
                    // create vectors for each direction
                    var vectorFwd = new THREE.Vector3(0, 0, 1); 
                    controls.getDirection(vectorFwd);
                    
                    var vectorLeft = new THREE.Vector3(-1, 0, 0); 
                    controls.getDirection(vectorLeft);
                    
                    var vectorRight = new THREE.Vector3(1, 0, 0); 
                    controls.getDirection(vectorRight);
                    
                    var vectorBack = new THREE.Vector3(0, 0, -1); 
                    controls.getDirection(vectorBack);
                    
                    vectorLeft.applyAxisAngle(rotateAxis, Math.PI / 2);
                    vectorRight.applyAxisAngle(rotateAxis,-Math.PI / 2);
                    vectorBack.applyAxisAngle(rotateAxis, Math.PI);
                    
                    var vector = new THREE.Vector3();
                    
                    if (moveForward) vector.add(vectorFwd);
                    if (moveLeft) vector.add(vectorLeft);
                    if (moveBackward) vector.add(vectorBack);
                    if (moveRight) vector.add(vectorRight);
                    
                    // apply speed to our vector
                    vector.normalize();
                    vector.multiplyScalar(speed);
                    
                    // If you don't want to allow the player to "fly", set to current Y velocity 
                    vector.y = player.getLinearVelocity().y;
                    
                    // now we just set the velocity to that vector
                    player.setLinearVelocity(vector);
                    
                    // set a flag to indicate that our player is moving
                    player.isMoving = true;
                    
                    //var cameraLookingAtVector = new THREE.Vector3(); // create once and reuse it!
                    //camera.getWorldDirection(cameraLookingAtVector);
                    //player.lookAt(cameraLookingAtVector);
                } 
                else 
                {
                    // if no keys were pressed, but player is still moving, slow the player down to a halt.
                    if (player.isMoving)
                    {
                        var vector = player.getLinearVelocity();
                        vector.normalize();
                        player.setLinearVelocity(vector);
                        player.isMoving = false;
                    }
                }
                
                //var lookWhereCameraIsLooking = new THREE.Vector3();
                //camera.getWorldDirection(lookWhereCameraIsLooking);
                //player.lookAt(lookWhereCameraIsLooking);
            }
        }
        
        function controlZombie()
        {
            if(controlsEnabled == true && zombie)
            {
                if (zombie.position.y < 4 && zombie.Health > 0) // Wait for the zombie to settle into place
                {
                    var zombieSpeed = 5;
                    var deltaBetweenPlayerAndZombie = new THREE.Vector3();
                    deltaBetweenPlayerAndZombie.subVectors(player.position, zombie.position);
                    deltaBetweenPlayerAndZombie.normalize();
                    deltaBetweenPlayerAndZombie.multiplyScalar(zombieSpeed);
                    
                    // If you don't want to allow the player to "fly", set to current Y velocity 
                    deltaBetweenPlayerAndZombie.y = zombie.getLinearVelocity().y;
                    
                    // now we just set the velocity to that vector
                    zombie.setLinearVelocity(deltaBetweenPlayerAndZombie);
                    
                    zombie.lookAt(player.position);
                    
                    //Needs more work to get the zombie facing the player...
                    zombie.rotation.y = Math.PI;// / 2;
                }
            }
        }
        
        /////// Bullets added April 6th
        function fireBullet(bullet_direction, bullet_size, bullet_mass) 
        {
            var bullet = new Physijs.ConvexMesh(new THREE.CylinderGeometry(bullet_size, bullet_size, bullet_size, 16), //new THREE.SphereGeometry(bullet_size, 16, 16),      
                                                Physijs.createMaterial(new THREE.MeshPhongMaterial({ambient: 0x000000, 
                                                                                                    color:0xbcc6cc, 
                                                                                                    shininess: 100.0, 
                                                                                                    emissive:0x111111, 
                                                                                                    specular: 0xbcc6cc, 
                                                                                                    metal: true}), 
                                                                       0.4, 
                                                                       0.4), 
                                                                      bullet_mass);
              
            
            bullet.applyMatrix( new THREE.Matrix4().makeTranslation( 0, length / 2, 0 ) );
            bullet.applyMatrix( new THREE.Matrix4().makeRotationX( Math.PI / 2 ) );
            bullet.lookAt( bullet_direction.normalize() );
            
            // Enable CCD if the object moves more than 1 meter in one simulation frame
            bullet.setCcdMotionThreshold(1);

            // Set the radius of the embedded sphere such that it is smaller than the object
            bullet.setCcdSweptSphereRadius(0.2);
            
            bullet.type = 'bullet';
            bullet.alive = true;
            bullet.castShadow = true;
            scene.add(bullet);
            bullets.push(bullet);
             
            bullet.__dirtyPosition = true;
            
            // Shoot in the direction we're facing, regardless of what the 'player'
            // object's forward facing direction is...
            if (bullet_direction.z < 0)                
                    bullet.position.set(player.position.x, player.position.y, player.position.z - bullet_size);
                else
                    bullet.position.set(player.position.x, player.position.y, player.position.z + bullet_size);
            
            bullet.setLinearVelocity(bullet_direction);
        }
        
    </script>
</body>

</html>
