<html>
<link rel="stylesheet" type="text/css" href="css/style.css">

<head></head>

<body>
    <div id="blocker">
        <div id="instructions">
            <span style="font-size:40px">Click to play</span>
            <br /> (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
        </div>
    </div>

    <!-- Include other libraries here (keep three.js at the top): -->
    <script src="js/Three.js"></script>
    <script src="js/PointerLockControls.js"></script>
    <script src="js/physi.js"></script>
    <!--<script src="js/OrbitControls.js"></script>-->

    <script>
        Physijs.scripts.worker = 'js/physijs_worker.js';
        Physijs.scripts.ammo = 'ammo.js';
    
        /* global THREE, Scoreboard, Physijs*/
        var camera, scene, renderer, controls, player, zombie, predatorSpeed, speed;
        
        
        /**
         * Player WASD Controls
         */
        // Keep track of W, A, S, D keypresses
        var keyW = false;
        var keyA = false;
        var keyS = false;
        var keyD = false;
        
        var objects = [];
        var raycaster;
        var mouseCoords = new THREE.Vector2();
        var projector = new THREE.Projector();
        
        var ballMaterial = new THREE.MeshPhongMaterial( { color: 0x202020 } );
        var pos = new THREE.Vector3();
        
        var blocker = document.getElementById('blocker');
        var instructions = document.getElementById('instructions');
        // http://www.html5rocks.com/en/tutorials/pointerlock/intro/
        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
        
        if (havePointerLock) {
            var element = document.body;
            var pointerlockchange = function(event) {
                if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                    controlsEnabled = true;
                    controls.enabled = true;
                    blocker.style.display = 'none';
                }
                else {
                    controls.enabled = false;
                    blocker.style.display = 'block';
                    instructions.style.display = '';
                }
            };
            var pointerlockerror = function(event) {
                instructions.style.display = '';
            };
            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerlockchange, false);
            document.addEventListener('mozpointerlockchange', pointerlockchange, false);
            document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
            document.addEventListener('pointerlockerror', pointerlockerror, false);
            document.addEventListener('mozpointerlockerror', pointerlockerror, false);
            document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
            instructions.addEventListener('click', function(event) {
                instructions.style.display = 'none';
                // Ask the browser to lock the pointer
                element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                element.requestPointerLock();
            }, false);
        }
        else {
            instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
        }
        
        init();
        animate();
        //PursuePrey();

        var controlsEnabled = false;
        var moveForward = false;
        var moveBackward = false;
        var moveLeft = false;
        var moveRight = false;
        var canJump = false;
        var prevTime = performance.now();
        var velocity = new THREE.Vector3();
        var direction = new THREE.Vector3();
        var shoot = false;

        function init() {
            // Setup the scene
            scene = new Physijs.Scene();
            scene.setGravity(new THREE.Vector3(0, -9.87, 0));
            scene.background = new THREE.Color(0xffffff);
            scene.fog = new THREE.Fog(0xffffff, 0, 750);
            
            var loader = new THREE.ObjectLoader();
			loader.load('models/gears-of-war-3-lambent-female.json',
			            function(obj)
			            {
			                //scene.add(obj);
			                //obj.position.x = 20;
			                //obj.position.z = 20;
			                //obj.position.y = -zombieHeight / 2;
			                
			                var zombieHeight = 6;
			                var zombieFriction = 0.5;
			                var zombieRestitution = 0.1;
			                var zombieMaterial = Physijs.createMaterial(new THREE.MeshNormalMaterial({ wireframe: true, opacity: 0.5 }),
			                                                            zombieFriction,
			                                                            zombieRestitution);
			                zombie = new Physijs.CapsuleMesh(new THREE.CylinderGeometry(1, 1, zombieHeight),
                			                                 zombieMaterial,
                			                                 1);
                			                                 
                			zombie.Health = 100;
                			                                 
                			zombie.addEventListener('collision', 
                			                        function(other_object, relative_velocity, relative_rotation, contact_normal) 
                			                        {
                			                            console.log('collision detected!');
                			                            
                			                            if (other_object.type == 'bullet')
                			                            {
                			                                other_object.alive = false;
                			                                
                                                            // the zombie has been hit!
                                                            this.Health -= 33;
                                                        
                                                            if (this.Health <= 0)
                                                            {
                                                                // Bye zombie!
                                                                scene.remove(this);
                                                            }
                			                            }
                			                        });
                			                                 
                			zombie.position.x = 23;
			                zombie.position.z = 23;
			                zombie.position.y = 2 + zombieHeight / 2;//20; //2 + zombieHeight / 2;
			                
			                obj.position.set(0, -zombieHeight / 2, 0);
			                zombie.add(obj);
			                scene.add(zombie);
			                zombie.setAngularFactor({ x: 0, y: 0, z: 0 });
			                
			                predatorSpeed = .25;
			            });
            
            //Enemies pursuit
            //var pursuePrey = new PredatorPrey();
            
            //
            
            // Setup our player.  Use CapsuleMesh so it can have more
            // realistic human-like movement
            var playerHeight = 3;
            player = new Physijs.CapsuleMesh(new THREE.CylinderGeometry(1, 1, playerHeight),
                                             new THREE.MeshNormalMaterial(),
                                             1);
                                             
            //player.visible = false; // FPS
            player.position.x = 20;
            player.position.z = 20;
            player.position.y = playerHeight / 2;
            
            scene.add(player);
            player.setAngularFactor({ x: 0, y: 0, z: 0 });
            
            // Setup the camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            //camera.position.y = 0;// playerHeight + 3;//set(0, 0, 40);
            player.add(camera);
            //camera.add(player);
            
            // Setup lighting
            var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);
            
            // Setup the pointer lock controls
            controls = new THREE.PointerLockControls(camera);

            scene.add(controls.getObject());
            
            // Use the controls object as the player's POV
            var pov = controls.getObject();
            player.add(pov);
            pov.position.set(0, playerHeight / 10, 10); //(playerHeight / 10), 7);
            
            var onKeyDown = function(event) {

                switch (event.keyCode) {
                    case 38: // up
                    case 87: // w
                        moveForward = true;
                        break;
                    case 37: // left
                    case 65: // a
                        moveLeft = true;
                        break;
                    case 40: // down
                    case 83: // s
                        moveBackward = true;
                        break;
                    case 39: // right
                    case 68: // d
                        moveRight = true;
                        break;
                    case 32: // space
                        if (canJump === true) //playerVelocity.y += 3;
                        canJump = false;
                        break;
                }
                
                //player.setLinearVelocity(playerVelocity);
            };
            
            var onKeyUp = function(event) {
                switch (event.keyCode) {
                    case 38: // up
                    case 87: // w
                        moveForward = false;
                        break;
                    case 37: // left
                    case 65: // a
                        moveLeft = false;
                        break;
                    case 40: // down
                    case 83: // s
                        moveBackward = false;
                        break;
                    case 39: // right
                    case 68: // d
                        moveRight = false;
                        break;
                }
            };
            
            var onMouseDown = function(event)
            {
    //             shoot = true;
                
    //             var vector = new THREE.Vector3(0,0,1);
    //             projector.unprojectVector(vector, camera);
    //             var ray = new THREE.Ray(camera.position, vector.sub(camera.position).normalize() );
    //             vector.copy(ray.direction);

				// // Creates a ball and throws it
				// var ballMass = 35;
				// var ballRadius = 4;

				// var ball = new Physijs.SphereMesh(new THREE.SphereGeometry( ballRadius, 14, 10 ), ballMaterial, ballMass );
				// ball.castShadow = true;
				// ball.receiveShadow = true;
				
				// scene.add(ball);
				
				// //var ballShape = new Ammo.btSphereShape( ballRadius );
				// //ballShape.setMargin( margin );
				// //pos.copy( raycaster.ray.direction );
				// //pos.add( raycaster.ray.origin );
				// //quat.set( 0, 0, 0, 1 );
				// //var ballBody = createRigidBody( ball, ballShape, ballMass, pos, quat );

				// //pos.copy( raycaster.ray.direction );
				// //pos.multiplyScalar( 240 );
				// vector.z = -vector.z;
				// ball.setLinearVelocity(vector); //new THREE.Vector3( pos.x, pos.y, pos.z ) );
            };
            
            
            window.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            
            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
            
            // Setup the floor of our scene
            var floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);
            
            for (var i = 0, l = floorGeometry.vertices.length; i < l; i++) {
                var vertex = floorGeometry.vertices[i];
                vertex.x += Math.random() * 20 - 10;
                vertex.y += Math.random() * 2;
                vertex.z += Math.random() * 20 - 10;
            }
            for (var i = 0, l = floorGeometry.faces.length; i < l; i++) {
                var face = floorGeometry.faces[i];
                face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
            }
            
            var floorMaterial = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors });
            
            var floor = new Physijs.BoxMesh(floorGeometry, //new THREE.BoxGeometry(2000, 1, 2000),//2000, 1, 2000), 
                                            floorMaterial,//new THREE.MeshBasicMaterial({color: 0xCCCCCC}),
                                            0);
                                            
            scene.add(floor);
            
            // objects
            /* var boxGeometry = new THREE.BoxGeometry(20, 20, 20);
             for (var i = 0, l = boxGeometry.faces.length; i < l; i++) {
                 var face = boxGeometry.faces[i];
                 face.vertexColors[0] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                 face.vertexColors[1] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                 face.vertexColors[2] = new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
             }
             for (var i = 0; i < 10; i++) {
                 var boxMaterial = new THREE.MeshPhongMaterial({ specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors });
                 boxMaterial.color.setHSL(Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                 var box = new THREE.Mesh(boxGeometry, boxMaterial);
                 box.position.x = Math.floor(Math.random() * 20 - 10) * 20;
                 box.position.y = Math.floor(Math.random() * 20) * 20 + 10;
                 box.position.z = Math.floor(Math.random() * 20 - 10) * 20;
                 scene.add(box);
                 objects.push(box);
             }*/

            //****begin world creation****

            //B represents a brick building
            //G represents a glass building
            var map = "B       G\n" +
                "     G  B\n" +
                "B       G\n" +
                "   B    B\n" +
                "B       G\n" +
                "        B\n" +
                "B       G\n" +
                "        B\n" +
                "B     G G";

            //convert our above string into arrays
            map = map.split("\n");
            var HORIZONTAL_UNIT = 100,
                VERTICAL_UNIT = 1000,
                ZSIZE = map.length * HORIZONTAL_UNIT,
                XSIZE = map[0].length * HORIZONTAL_UNIT;

            for (var i = 0, rows = map.length; i < rows; i++) {
                for (var j = 0, cols = map[i].length; j < cols; j++) {
                    addObject(map[i].charAt(j), i, j);
                }
            }

            function addObject(type, row, col) {
                var z = (row + 1) * HORIZONTAL_UNIT - ZSIZE * 0.5,
                    x = (col + 1) * HORIZONTAL_UNIT - XSIZE * 0.5;

                var mesh, geo, material;

                if (type == '') {

                }
                else if (type == 'B') {
                   var brickTexture = THREE.ImageUtils.loadTexture('textures/brick.jpg');
                    brickTexture.wrapS = brickTexture.wrapT = THREE.RepeatWrapping;
                    brickTexture.repeat.set(10, 50);
                   
                   
                    geo = new Physijs.BoxMesh(
                        new THREE.CubeGeometry(HORIZONTAL_UNIT, VERTICAL_UNIT, HORIZONTAL_UNIT),
                        new THREE.MeshBasicMaterial({map: brickTexture}),
                        100000000
                        );
                   
                    geo.position.set(x, VERTICAL_UNIT * 0.5, z);
                    scene.add(geo);
                }
                else if (type == 'G') {
                    var windowTexture = THREE.ImageUtils.loadTexture('textures/glasswindows.jpg');
                    windowTexture.wrapS = windowTexture.wrapT = THREE.RepeatWrapping;
                    windowTexture.repeat.set(10, 50);
                    
                    geo = new Physijs.BoxMesh(
                        new THREE.CubeGeometry(HORIZONTAL_UNIT, VERTICAL_UNIT, HORIZONTAL_UNIT),
                        new THREE.MeshBasicMaterial({map: windowTexture}),
                        100000000
                        );
                    
                    geo.position.set(x, VERTICAL_UNIT * 0.5, z);
                    scene.add(geo);
                }
            }
            

            //****end world creation****
            /*//Collision detection
            var ball = new Physijs.SphereMesh( 
            new THREE.SphereGeometry(3),
            new THREE.MeshBasicMaterial({color: 0x888888}) */
         
            
        
            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            //
            window.addEventListener('resize', onWindowResize, false);
        }
  
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            scene.simulate();
            controlPlayer();
        	pursuePrey();//zombie, player, .75, speed);
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
    
        function controlPlayer() 
        {
            if (controlsEnabled == true) 
            {
                if (moveForward || moveBackward || moveLeft || moveRight)
                {
                    // Change this to the speed you want your player to move
                     speed = 25;
                    
                    // Our player is a pill shape, so this keeps our player from accidentally tipping over
                    player.setAngularFactor({ x: 0, y: 0, z: 0 });
                    
                    // We want to rotate our vector around the Y axis
                    var rotateAxis = new THREE.Vector3(0, 1, 0);
                    
                    // Get a vector based on our direction
                
                    // create vectors for each direction
                    var vectorFwd = new THREE.Vector3(); 
                    controls.getDirection(vectorFwd);// getDirection;
                    
                    var vectorLeft = new THREE.Vector3(); 
                    controls.getDirection(vectorLeft);
                    
                    var vectorRight = new THREE.Vector3(); 
                    controls.getDirection(vectorRight);
                    
                    var vectorBack = new THREE.Vector3(); 
                    controls.getDirection(vectorBack);
                    
                    vectorLeft.applyAxisAngle(rotateAxis, Math.PI / 2);
                    vectorRight.applyAxisAngle(rotateAxis,-Math.PI / 2);
                    vectorBack.applyAxisAngle(rotateAxis, Math.PI);
                    
                    var vector = new THREE.Vector3();
                    
                    if (moveForward) vector.add(vectorFwd);
                    if (moveLeft) vector.add(vectorLeft);
                    if (moveBackward) vector.add(vectorBack);
                    if (moveRight) vector.add(vectorRight);
                    
                    // apply speed to our vector
                    vector.normalize();
                    vector.multiplyScalar(speed);
                    
                    // If you don't want to allow the player to "fly", set to current Y velocity 
                    vector.y = player.getLinearVelocity().y;
                    
                    // now we just set the velocity to that vector
                    player.setLinearVelocity(vector);
                    
                    // set a flag to indicate that our player is moving
                    player.isMoving = true;
                } 
                else 
                {
                    // if no keys are , but player is still moving, slow the player down to a halt.
                    if (player.isMoving)
                    {
                        var vector = player.getLinearVelocity();
                        vector.normalize();
                        player.setLinearVelocity(vector);
                        player.isMoving = false;
                    }
                }
            }
        }
        
        function pursuePrey()//predator, prey, predatorSpeed, preySpeed) 
        {
            if (zombie)
            {
                if (controlsEnabled) 
                {
                    //create two vector objects
                    var xd = new THREE.Vector3(player.position.x, player.position.y, player.position.z);
                    var yd = new THREE.Vector3(zombie.position.x, zombie.position.y, zombie.position.z);
                    //find the distance / hypotenuse to the xyz location
                    var hypotenuse = zombie.position.distanceTo(player.position);
            
                    var subvec = new THREE.Vector3();
                    subvec = subvec.sub(xd, yd);
            
                    //move zombie closer if farther away than 10 pixels.
                    if (hypotenuse > 10) {
                        //console.log(hypotenuse);
                        //zombie.position.y += predatorSpeed * speed * (subvec.y / hypotenuse);
                        zombie.position.x += predatorSpeed * speed * (subvec.x / hypotenuse);
                        zombie.position.z += predatorSpeed * speed * (subvec.z / hypotenuse);
                    }
                    
                    //if zombie gets within 20 pixels run the following code
                    if (hypotenuse < 20) {
                        //within attack range
                        console.log("Attack!");
                        // scoreboard.subtractPoints(10);
                        var x = (Math.random() * 200) - 200 / 1;
            		    var z = (Math.random() * 200) - 200 / 1;
                        //zombie.position.set(x, -50, z);
                        console.log(x);
                        console.log(z);
                        zombie.position.set(x, 3, z);
                    }
                }
            }
        }
        
    </script>
</body>

</html>
